// Code generated by P30599-IPC-Generator/ipcgen/internal/built-in-plugins/client; DO NOT EDIT.
package testsdkgo

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/sirupsen/logrus"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
)

// DefaultAPI holds the operations grouped on the 'Default' tag.
type DefaultAPI interface {
	// DeleteOrder creates a new DeleteOrderRequest for 'DeleteOrder'
	// @Param orderID path ID of order that needs to be Deleted
	// @Failure 400 DeleteOrderBadRequest
	// @Failure 404 DeleteOrderNotFound
	// @Router DELETE [/store/order/{orderID}]
	//
	// The request can be executed using DeleteOrderRequest.Execute()
	DeleteOrder(context.Context, DeleteOrderParams) DeleteOrderRequest

	// DeleteOrderExecute executes a DeleteOrderRequest to return one
	// of the possible DeleteOrder success/error responses, the raw *http.Response and an error
	DeleteOrderExecute(DeleteOrderRequest) (DeleteOrderSuccess, DeleteOrderError, *http.Response, error)
}

// DefaultService is registered on the root Client and can create requests for the
// operations grouped on 'Default' and execute them.
type DefaultService struct {
	// Client used to execute requests
	Client *http.Client
	// Configuration used to create requests
	Configuration *Configuration
}

// DeleteOrderSuccess must be implemented by all responses for DELETE /store/order/{orderID} that indicate success
type DeleteOrderSuccess interface {
	requireTypeOf[DeleteOrderSuccess]
}

// DeleteOrderError must be implemented by all responses DELETE /store/order/{orderID} that indicate failure
type DeleteOrderError interface {
	requireTypeOf[DeleteOrderError]
}

// DeleteOrderParams are parsed from the URL for DELETE /store/order/{orderID}
type DeleteOrderParams struct {
	OrderID int64 `json:"orderID" uri:"orderID"`
}

type DeleteOrderBadRequest struct {
	isTypeOf[DeleteOrderError]
	httpStatus400
}

type DeleteOrderNotFound struct {
	isTypeOf[DeleteOrderError]
	httpStatus404
}

// DeleteOrderRequest holds a constructed *http.Request that can be executed
// on the *http.Client in the passed context.Context
type DeleteOrderRequest struct {
	// Context in which to execute request
	Context context.Context
	// Client used to execute request
	Client *http.Client
	// Request that will be executed
	Request *http.Request
	// ResponseMiddleware functions executed on the *http.Response before it is processed by the Execute function
	ResponseMiddleware []ResponseMiddlewareFunction
	// metrics tracked during request
	Metrics *Metrics
	// Error in request creation. The Error is tracked as part of the DeleteOrderRequest to one-line
	// the execution in Client.DefaultAPI.DeleteOrder.Execute()
	Error error
}

// DeleteOrder constructs a new DeleteOrderRequest
func (a *DefaultService) DeleteOrder(ctx context.Context, params DeleteOrderParams) DeleteOrderRequest {
	res := DeleteOrderRequest{
		Context:            ctx,
		Client:             a.Client,
		ResponseMiddleware: a.Configuration.ResponseMiddleware,
		Metrics:            a.Configuration.Metrics,
	}

	path := a.Configuration.BasePath + "/store/order/{orderID}"
	rawPath := path
	path = strings.Replace(path, ":orderID", fmt.Sprint(params.OrderID), 1)
	rawPath = strings.Replace(rawPath, ":orderID", url.PathEscape(fmt.Sprint(params.OrderID)), 1)
	query := []string{}

	u := &url.URL{
		Scheme:   a.Configuration.Scheme,
		Host:     fmt.Sprintf("%s:%d", a.Configuration.Host, a.Configuration.Port),
		Path:     path,
		RawQuery: strings.Join(query, "&"),
	}

	if path != rawPath {
		u.RawPath = rawPath
	}

	// set headers for request
	header := map[string][]string{}
	for k, v := range a.Configuration.DefaultHeader {
		header[k] = []string{v}
	}

	req := &http.Request{
		Method: http.MethodDelete,
		URL:    u,
		Header: header,
		Host:   a.Configuration.Host,
	}

	// add context to request
	req = req.WithContext(ctx)

	// inject trace in request
	carrier := propagation.HeaderCarrier(req.Header)
	propagator := otel.GetTextMapPropagator()
	propagator.Inject(ctx, carrier)

	// Apply middlewares
	for _, middleware := range a.Configuration.RequestMiddleware {
		if err := middleware(req); err != nil {
			res.Error = err
			return res
		}
	}

	res.Request = req
	return res
}

// DeleteOrderExecute a DeleteOrderRequest on the DefaultService
// as a convenience function.
func (a *DefaultService) DeleteOrderExecute(r DeleteOrderRequest) (DeleteOrderSuccess, DeleteOrderError, *http.Response, error) {
	return r.Execute()
}

// DeleteOrder the DeleteOrderRequest towards [DELETE] /store/order/{orderID} and
// return either the success response (1xx-3xx) or failure response (4xx-5xx), the raw *http.Response or an error if the request could not be executed
func (r DeleteOrderRequest) Execute() (DeleteOrderSuccess, DeleteOrderError, *http.Response, error) {
	ctx, span := otel.Tracer("").Start(r.Context, "DeleteOrder")
	log := logrus.WithContext(ctx)
	defer span.End()

	var statusCode int
	before := time.Now()
	if m := r.Metrics; m != nil {
		defer func() {
			m.Counter.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.DefaultCounter.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.DeleteOrderCounter.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			if statusCode != 0 {
				duration := time.Since(before)
				m.Histogram.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.DefaultHistogram.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.DeleteOrderHistogram.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
			}
		}()
	}

	res, err := r.Client.Do(r.Request)
	if err != nil {
		log.WithError(err).Errorf("failed to perform request for path '%s'", r.Request.URL.Path)
		return nil, nil, nil, err
	}

	// for metrics
	statusCode = res.StatusCode

	// Apply middlewares
	for _, middleware := range r.ResponseMiddleware {
		if err := middleware(res); err != nil {
			log.WithError(err).Errorf("response middleware returns error for path '%s'", r.Request.URL.Path)
			return nil, nil, res, err
		}
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to parse body for status code '%d'", res.StatusCode)
		return nil, nil, res, err
	}

	switch res.StatusCode {
	case http.StatusBadRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 400, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotFound:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 404, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	}

	// if a response is received that is not specified in the OpenAPI specification, log the response with an error
	if res.Body == nil {
		err := fmt.Errorf("received unknown response '%d' without body", res.StatusCode)
		log.Error(err.Error())

		return nil, nil, res, err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to read body for unknown response with status code '%d'", res.StatusCode)

		return nil, nil, res, err
	}

	err = fmt.Errorf("received unknown response '%d' with body %v", res.StatusCode, string(b))
	log.WithError(err).Error("failed to execute request")

	return nil, nil, res, err
}
