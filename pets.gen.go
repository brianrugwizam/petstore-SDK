// Code generated by P30599-IPC-Generator/ipcgen/internal/built-in-plugins/client; DO NOT EDIT.
package testsdkgo

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/sirupsen/logrus"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
)

// PetsAPI holds the operations grouped on the 'pets' tag.
type PetsAPI interface {
	// ListPets Creates a new ListPetsRequest for 'ListPets'
	// @Summary List all pets
	// @Tags [pets]
	// @Param limit query How many items to return at one time (max 100)
	// @Success 200 ListPetsOK
	// @Failure 400 ListPetsBadRequest
	// @Failure 401 ListPetsUnauthorized
	// @Failure 402 ListPetsPaymentRequired
	// @Failure 403 ListPetsForbidden
	// @Failure 404 ListPetsNotFound
	// @Failure 405 ListPetsMethodNotAllowed
	// @Failure 406 ListPetsNotAcceptable
	// @Failure 407 ListPetsProxyAuthRequired
	// @Failure 408 ListPetsRequestTimeout
	// @Failure 409 ListPetsConflict
	// @Failure 410 ListPetsGone
	// @Failure 411 ListPetsLengthRequired
	// @Failure 412 ListPetsPreconditionFailed
	// @Failure 413 ListPetsRequestEntityTooLarge
	// @Failure 414 ListPetsRequestURITooLong
	// @Failure 415 ListPetsUnsupportedMediaType
	// @Failure 416 ListPetsRequestedRangeNotSatisfiable
	// @Failure 417 ListPetsExpectationFailed
	// @Failure 418 ListPetsTeapot
	// @Failure 421 ListPetsMisdirectedRequest
	// @Failure 422 ListPetsUnprocessableEntity
	// @Failure 423 ListPetsLocked
	// @Failure 424 ListPetsFailedDependency
	// @Failure 425 ListPetsTooEarly
	// @Failure 426 ListPetsUpgradeRequired
	// @Failure 428 ListPetsPreconditionRequired
	// @Failure 429 ListPetsTooManyRequests
	// @Failure 431 ListPetsRequestHeaderFieldsTooLarge
	// @Failure 451 ListPetsUnavailableForLegalReasons
	// @Failure 500 ListPetsInternalServerError
	// @Failure 501 ListPetsNotImplemented
	// @Failure 502 ListPetsBadGateway
	// @Failure 503 ListPetsServiceUnavailable
	// @Failure 504 ListPetsGatewayTimeout
	// @Failure 505 ListPetsHTTPVersionNotSupported
	// @Failure 506 ListPetsVariantAlsoNegotiates
	// @Failure 507 ListPetsInsufficientStorage
	// @Failure 508 ListPetsLoopDetected
	// @Failure 510 ListPetsNotExtended
	// @Failure 511 ListPetsNetworkAuthenticationRequired
	// @Router GET [/pets]
	//
	// The request can be executed using ListPetsRequest.Execute()
	ListPets(context.Context, ListPetsParams) ListPetsRequest

	// ListPetsExecute executes a ListPetsRequest to return one
	// of the possible ListPets success/error responses, the raw *http.Response and an error
	ListPetsExecute(ListPetsRequest) (ListPetsSuccess, ListPetsError, *http.Response, error)

	// CreatePet Creates a new CreatePetRequest for 'CreatePet'
	// @Summary Create a pet
	// @Tags [pets]
	// @Success 201 CreatePetCreated
	// @Failure 400 CreatePetBadRequest
	// @Failure 401 CreatePetUnauthorized
	// @Failure 402 CreatePetPaymentRequired
	// @Failure 403 CreatePetForbidden
	// @Failure 404 CreatePetNotFound
	// @Failure 405 CreatePetMethodNotAllowed
	// @Failure 406 CreatePetNotAcceptable
	// @Failure 407 CreatePetProxyAuthRequired
	// @Failure 408 CreatePetRequestTimeout
	// @Failure 409 CreatePetConflict
	// @Failure 410 CreatePetGone
	// @Failure 411 CreatePetLengthRequired
	// @Failure 412 CreatePetPreconditionFailed
	// @Failure 413 CreatePetRequestEntityTooLarge
	// @Failure 414 CreatePetRequestURITooLong
	// @Failure 415 CreatePetUnsupportedMediaType
	// @Failure 416 CreatePetRequestedRangeNotSatisfiable
	// @Failure 417 CreatePetExpectationFailed
	// @Failure 418 CreatePetTeapot
	// @Failure 421 CreatePetMisdirectedRequest
	// @Failure 422 CreatePetUnprocessableEntity
	// @Failure 423 CreatePetLocked
	// @Failure 424 CreatePetFailedDependency
	// @Failure 425 CreatePetTooEarly
	// @Failure 426 CreatePetUpgradeRequired
	// @Failure 428 CreatePetPreconditionRequired
	// @Failure 429 CreatePetTooManyRequests
	// @Failure 431 CreatePetRequestHeaderFieldsTooLarge
	// @Failure 451 CreatePetUnavailableForLegalReasons
	// @Failure 500 CreatePetInternalServerError
	// @Failure 501 CreatePetNotImplemented
	// @Failure 502 CreatePetBadGateway
	// @Failure 503 CreatePetServiceUnavailable
	// @Failure 504 CreatePetGatewayTimeout
	// @Failure 505 CreatePetHTTPVersionNotSupported
	// @Failure 506 CreatePetVariantAlsoNegotiates
	// @Failure 507 CreatePetInsufficientStorage
	// @Failure 508 CreatePetLoopDetected
	// @Failure 510 CreatePetNotExtended
	// @Failure 511 CreatePetNetworkAuthenticationRequired
	// @Router POST [/pets]
	//
	// The request can be executed using CreatePetRequest.Execute()
	CreatePet(context.Context, CreatePetBody) CreatePetRequest

	// CreatePetExecute executes a CreatePetRequest to return one
	// of the possible CreatePet success/error responses, the raw *http.Response and an error
	CreatePetExecute(CreatePetRequest) (CreatePetSuccess, CreatePetError, *http.Response, error)

	// DeletePet Creates a new DeletePetRequest for 'DeletePet'
	// @Summary Delete a pet by ID
	// @Tags [pets]
	// @Param id path The id of the pet to retrieve
	// @Success 204 DeletePetNoContent
	// @Failure 400 DeletePetBadRequest
	// @Failure 404 DeletePetNotFound
	// @Failure 500 DeletePetInternalServerError
	// @Router DELETE [/pets/{id}]
	//
	// The request can be executed using DeletePetRequest.Execute()
	DeletePet(context.Context, DeletePetParams) DeletePetRequest

	// DeletePetExecute executes a DeletePetRequest to return one
	// of the possible DeletePet success/error responses, the raw *http.Response and an error
	DeletePetExecute(DeletePetRequest) (DeletePetSuccess, DeletePetError, *http.Response, error)

	// ShowPetByID Creates a new ShowPetByIDRequest for 'ShowPetById'
	// @Summary Info for a specific pet
	// @Tags [pets]
	// @Param id path The id of the pet to retrieve
	// @Success 200 ShowPetByIDOK
	// @Failure 400 ShowPetByIDBadRequest
	// @Failure 401 ShowPetByIDUnauthorized
	// @Failure 402 ShowPetByIDPaymentRequired
	// @Failure 403 ShowPetByIDForbidden
	// @Failure 404 ShowPetByIDNotFound
	// @Failure 405 ShowPetByIDMethodNotAllowed
	// @Failure 406 ShowPetByIDNotAcceptable
	// @Failure 407 ShowPetByIDProxyAuthRequired
	// @Failure 408 ShowPetByIDRequestTimeout
	// @Failure 409 ShowPetByIDConflict
	// @Failure 410 ShowPetByIDGone
	// @Failure 411 ShowPetByIDLengthRequired
	// @Failure 412 ShowPetByIDPreconditionFailed
	// @Failure 413 ShowPetByIDRequestEntityTooLarge
	// @Failure 414 ShowPetByIDRequestURITooLong
	// @Failure 415 ShowPetByIDUnsupportedMediaType
	// @Failure 416 ShowPetByIDRequestedRangeNotSatisfiable
	// @Failure 417 ShowPetByIDExpectationFailed
	// @Failure 418 ShowPetByIDTeapot
	// @Failure 421 ShowPetByIDMisdirectedRequest
	// @Failure 422 ShowPetByIDUnprocessableEntity
	// @Failure 423 ShowPetByIDLocked
	// @Failure 424 ShowPetByIDFailedDependency
	// @Failure 425 ShowPetByIDTooEarly
	// @Failure 426 ShowPetByIDUpgradeRequired
	// @Failure 428 ShowPetByIDPreconditionRequired
	// @Failure 429 ShowPetByIDTooManyRequests
	// @Failure 431 ShowPetByIDRequestHeaderFieldsTooLarge
	// @Failure 451 ShowPetByIDUnavailableForLegalReasons
	// @Failure 500 ShowPetByIDInternalServerError
	// @Failure 501 ShowPetByIDNotImplemented
	// @Failure 502 ShowPetByIDBadGateway
	// @Failure 503 ShowPetByIDServiceUnavailable
	// @Failure 504 ShowPetByIDGatewayTimeout
	// @Failure 505 ShowPetByIDHTTPVersionNotSupported
	// @Failure 506 ShowPetByIDVariantAlsoNegotiates
	// @Failure 507 ShowPetByIDInsufficientStorage
	// @Failure 508 ShowPetByIDLoopDetected
	// @Failure 510 ShowPetByIDNotExtended
	// @Failure 511 ShowPetByIDNetworkAuthenticationRequired
	// @Router GET [/pets/{id}]
	//
	// The request can be executed using ShowPetByIDRequest.Execute()
	ShowPetByID(context.Context, ShowPetByIDParams) ShowPetByIDRequest

	// ShowPetByIDExecute executes a ShowPetByIDRequest to return one
	// of the possible ShowPetById success/error responses, the raw *http.Response and an error
	ShowPetByIDExecute(ShowPetByIDRequest) (ShowPetByIDSuccess, ShowPetByIDError, *http.Response, error)

	// UpdatePet Creates a new UpdatePetRequest for 'UpdatePet'
	// @Summary edit a specific pet
	// @Tags [pets]
	// @Param id path The id of the pet to retrieve
	// @Success 200 UpdatePetOK
	// @Failure 400 UpdatePetBadRequest
	// @Failure 401 UpdatePetUnauthorized
	// @Failure 402 UpdatePetPaymentRequired
	// @Failure 403 UpdatePetForbidden
	// @Failure 404 UpdatePetNotFound
	// @Failure 405 UpdatePetMethodNotAllowed
	// @Failure 406 UpdatePetNotAcceptable
	// @Failure 407 UpdatePetProxyAuthRequired
	// @Failure 408 UpdatePetRequestTimeout
	// @Failure 409 UpdatePetConflict
	// @Failure 410 UpdatePetGone
	// @Failure 411 UpdatePetLengthRequired
	// @Failure 412 UpdatePetPreconditionFailed
	// @Failure 413 UpdatePetRequestEntityTooLarge
	// @Failure 414 UpdatePetRequestURITooLong
	// @Failure 415 UpdatePetUnsupportedMediaType
	// @Failure 416 UpdatePetRequestedRangeNotSatisfiable
	// @Failure 417 UpdatePetExpectationFailed
	// @Failure 418 UpdatePetTeapot
	// @Failure 421 UpdatePetMisdirectedRequest
	// @Failure 422 UpdatePetUnprocessableEntity
	// @Failure 423 UpdatePetLocked
	// @Failure 424 UpdatePetFailedDependency
	// @Failure 425 UpdatePetTooEarly
	// @Failure 426 UpdatePetUpgradeRequired
	// @Failure 428 UpdatePetPreconditionRequired
	// @Failure 429 UpdatePetTooManyRequests
	// @Failure 431 UpdatePetRequestHeaderFieldsTooLarge
	// @Failure 451 UpdatePetUnavailableForLegalReasons
	// @Failure 500 UpdatePetInternalServerError
	// @Failure 501 UpdatePetNotImplemented
	// @Failure 502 UpdatePetBadGateway
	// @Failure 503 UpdatePetServiceUnavailable
	// @Failure 504 UpdatePetGatewayTimeout
	// @Failure 505 UpdatePetHTTPVersionNotSupported
	// @Failure 506 UpdatePetVariantAlsoNegotiates
	// @Failure 507 UpdatePetInsufficientStorage
	// @Failure 508 UpdatePetLoopDetected
	// @Failure 510 UpdatePetNotExtended
	// @Failure 511 UpdatePetNetworkAuthenticationRequired
	// @Router PUT [/pets/{id}]
	//
	// The request can be executed using UpdatePetRequest.Execute()
	UpdatePet(context.Context, UpdatePetParams) UpdatePetRequest

	// UpdatePetExecute executes a UpdatePetRequest to return one
	// of the possible UpdatePet success/error responses, the raw *http.Response and an error
	UpdatePetExecute(UpdatePetRequest) (UpdatePetSuccess, UpdatePetError, *http.Response, error)
}

// PetsService is registered on the root Client and can Create requests for the
// operations grouped on 'pets' and execute them.
type PetsService struct {
	// Client used to execute requests
	Client *http.Client
	// Configuration used to Create requests
	Configuration *Configuration
}

// ListPetsSuccess must be implemented by all responses for GET /pets that indicate success
type ListPetsSuccess interface {
	requireTypeOf[ListPetsSuccess]
}

// ListPetsError must be implemented by all responses GET /pets that indicate failure
type ListPetsError interface {
	requireTypeOf[ListPetsError]
}

// ListPetsParams are parsed from the URL for GET /pets
type ListPetsParams struct {
	Limit int32 `form:"limit" json:"limit"`
}

type ListPetsOk struct {
	isTypeOf[ListPetsSuccess]
	httpStatus200
	// MetaData contains metadata of the response, such as record count, pagination and other additional information.
	Meta DefaultPaginatedMeta
	Data []Pet
	// Errors specifies a List of errors that occurred, can be filled using error handlers.
	Errors DefaultPaginatedErrors
}

type ListPetsBadRequest struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus400
}

type ListPetsUnauthorized struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus401
}

type ListPetsPaymentRequired struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus402
}

type ListPetsForbidden struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus403
}

type ListPetsNotFound struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus404
}

type ListPetsMethodNotAllowed struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus405
}

type ListPetsNotAcceptable struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus406
}

type ListPetsProxyAuthRequired struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus407
}

type ListPetsRequestTimeout struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus408
}

type ListPetsConflict struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus409
}

type ListPetsGone struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus410
}

type ListPetsLengthRequired struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus411
}

type ListPetsPreconditionFailed struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus412
}

type ListPetsRequestEntityTooLarge struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus413
}

type ListPetsRequestURITooLong struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus414
}

type ListPetsUnsupportedMediaType struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus415
}

type ListPetsRequestedRangeNotSatisfiable struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus416
}

type ListPetsExpectationFailed struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus417
}

type ListPetsTeapot struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus418
}

type ListPetsMisdirectedRequest struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus421
}

type ListPetsUnprocessableEntity struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus422
}

type ListPetsLocked struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus423
}

type ListPetsFailedDependency struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus424
}

type ListPetsTooEarly struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus425
}

type ListPetsUpgradeRequired struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus426
}

type ListPetsPreconditionRequired struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus428
}

type ListPetsTooManyRequests struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus429
}

type ListPetsRequestHeaderFieldsTooLarge struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus431
}

type ListPetsUnavailableForLegalReasons struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus451
}

type ListPetsInternalServerError struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus500
}

type ListPetsNotImplemented struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus501
}

type ListPetsBadGateway struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus502
}

type ListPetsServiceUnavailable struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus503
}

type ListPetsGatewayTimeout struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus504
}

type ListPetsHTTPVersionNotSupported struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus505
}

type ListPetsVariantAlsoNegotiates struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus506
}

type ListPetsInsufficientStorage struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus507
}

type ListPetsLoopDetected struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus508
}

type ListPetsNotExtended struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus510
}

type ListPetsNetworkAuthenticationRequired struct {
	Error
	isTypeOf[ListPetsError]
	httpStatus511
}

// ListPetsRequest holds a constructed *http.Request that can be executed
// on the *http.Client in the passed context.Context
type ListPetsRequest struct {
	// Context in which to execute request
	Context context.Context
	// Client used to execute request
	Client *http.Client
	// Request that will be executed
	Request *http.Request
	// ResponseMiddleware functions executed on the *http.Response before it is processed by the Execute function
	ResponseMiddleware []ResponseMiddlewareFunction
	// metrics tracked during request
	Metrics *Metrics
	// Error in request creation. The Error is tracked as part of the ListPetsRequest to one-line
	// the execution in Client.PetsAPI.ListPets.Execute()
	Error error
}

// ListPets constructs a new ListPetsRequest
func (a *PetsService) ListPets(ctx context.Context, params ListPetsParams) ListPetsRequest {
	res := ListPetsRequest{
		Context:            ctx,
		Client:             a.Client,
		ResponseMiddleware: a.Configuration.ResponseMiddleware,
		Metrics:            a.Configuration.Metrics,
	}

	path := a.Configuration.BasePath + "/pets"
	rawPath := path
	compareParams := ListPetsParams{}
	_ = compareParams // ensure usage
	query := []string{}
	if params.Limit != compareParams.Limit {
		queryEscaped := url.QueryEscape(fmt.Sprint(params.Limit))
		query = append(query, "limit="+queryEscaped)
	}

	u := &url.URL{
		Scheme:   a.Configuration.Scheme,
		Host:     fmt.Sprintf("%s:%d", a.Configuration.Host, a.Configuration.Port),
		Path:     path,
		RawQuery: strings.Join(query, "&"),
	}

	if path != rawPath {
		u.RawPath = rawPath
	}

	// set headers for request
	header := map[string][]string{}
	for k, v := range a.Configuration.DefaultHeader {
		header[k] = []string{v}
	}

	req := &http.Request{
		Method: http.MethodGet,
		URL:    u,
		Header: header,
		Host:   a.Configuration.Host,
	}

	// add context to request
	req = req.WithContext(ctx)

	// inject trace in request
	carrier := propagation.HeaderCarrier(req.Header)
	propagator := otel.GetTextMapPropagator()
	propagator.Inject(ctx, carrier)

	// Apply middlewares
	for _, middleware := range a.Configuration.RequestMiddleware {
		if err := middleware(req); err != nil {
			res.Error = err
			return res
		}
	}

	res.Request = req
	return res
}

// ListPetsExecute a ListPetsRequest on the PetsService
// as a convenience function.
func (a *PetsService) ListPetsExecute(r ListPetsRequest) (ListPetsSuccess, ListPetsError, *http.Response, error) {
	return r.Execute()
}

// ListPets the ListPetsRequest towards [GET] /pets and
// return either the success response (1xx-3xx) or failure response (4xx-5xx), the raw *http.Response or an error if the request could not be executed
func (r ListPetsRequest) Execute() (ListPetsSuccess, ListPetsError, *http.Response, error) {
	ctx, span := otel.Tracer("").Start(r.Context, "ListPets")
	log := logrus.WithContext(ctx)
	defer span.End()

	var statusCode int
	before := time.Now()
	if m := r.Metrics; m != nil {
		defer func() {
			m.Counter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.PetsCounter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.ListPetsCounter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			if statusCode != 0 {
				duration := time.Since(before)
				m.Histogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.PetsHistogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.ListPetsHistogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
			}
		}()
	}

	res, err := r.Client.Do(r.Request)
	if err != nil {
		log.WithError(err).Errorf("failed to perform request for path '%s'", r.Request.URL.Path)
		return nil, nil, nil, err
	}

	// for metrics
	statusCode = res.StatusCode

	// Apply middlewares
	for _, middleware := range r.ResponseMiddleware {
		if err := middleware(res); err != nil {
			log.WithError(err).Errorf("response middleware returns error for path '%s'", r.Request.URL.Path)
			return nil, nil, res, err
		}
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to parse body for status code '%d'", res.StatusCode)
		return nil, nil, res, err
	}

	switch res.StatusCode {
	case http.StatusOK:
		var success ListPetsOk
		if err := json.Unmarshal(bodyBytes, &success); err != nil {
			log.WithError(err).Errorf("failed to unmarshal body for status code '%d': %v", 200, string(bodyBytes))
			return nil, nil, res, err
		}
		return &success, nil, res, nil
	case http.StatusBadRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 400, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnauthorized:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 401, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPaymentRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 402, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusForbidden:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 403, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotFound:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 404, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusMethodNotAllowed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 405, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotAcceptable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 406, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusProxyAuthRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 407, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestTimeout:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 408, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusConflict:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 409, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusGone:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 410, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLengthRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 411, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPreconditionFailed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 412, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestEntityTooLarge:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 413, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestURITooLong:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 414, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnsupportedMediaType:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 415, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestedRangeNotSatisfiable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 416, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusExpectationFailed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 417, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTeapot:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 418, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusMisdirectedRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 421, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnprocessableEntity:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 422, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLocked:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 423, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusFailedDependency:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 424, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTooEarly:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 425, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUpgradeRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 426, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPreconditionRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 428, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTooManyRequests:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 429, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestHeaderFieldsTooLarge:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 431, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnavailableForLegalReasons:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 451, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInternalServerError:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 500, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotImplemented:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 501, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusBadGateway:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 502, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusServiceUnavailable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 503, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusGatewayTimeout:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 504, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusHTTPVersionNotSupported:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 505, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusVariantAlsoNegotiates:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 506, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInsufficientStorage:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 507, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLoopDetected:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 508, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotExtended:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 510, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNetworkAuthenticationRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 511, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	}

	// if a response is received that is not specified in the OpenAPI specification, log the response with an error
	if res.Body == nil {
		err := fmt.Errorf("received unknown response '%d' without body", res.StatusCode)
		log.Error(err.Error())

		return nil, nil, res, err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to read body for unknown response with status code '%d'", res.StatusCode)

		return nil, nil, res, err
	}

	err = fmt.Errorf("received unknown response '%d' with body %v", res.StatusCode, string(b))
	log.WithError(err).Error("failed to execute request")

	return nil, nil, res, err
}

// CreatePetSuccess must be implemented by all responses for POST /pets that indicate success
type CreatePetSuccess interface {
	requireTypeOf[CreatePetSuccess]
}

// CreatePetError must be implemented by all responses POST /pets that indicate failure
type CreatePetError interface {
	requireTypeOf[CreatePetError]
}

// CreatePetBody are parsed from the request body for POST /pets
type CreatePetBody struct {
	Pet
}

type CreatePetCreated struct {
	isTypeOf[CreatePetSuccess]
	httpStatus201
	// MetaData contains metadata of the response, such as record count, pagination and other additional information.
	Meta DefaultResponseMeta
	Data Pet
	// Errors specifies a List of errors that occurred, can be filled using error handlers.
	Errors DefaultResponseErrors
}

type CreatePetBadRequest struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus400
}

type CreatePetUnauthorized struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus401
}

type CreatePetPaymentRequired struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus402
}

type CreatePetForbidden struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus403
}

type CreatePetNotFound struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus404
}

type CreatePetMethodNotAllowed struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus405
}

type CreatePetNotAcceptable struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus406
}

type CreatePetProxyAuthRequired struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus407
}

type CreatePetRequestTimeout struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus408
}

type CreatePetConflict struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus409
}

type CreatePetGone struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus410
}

type CreatePetLengthRequired struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus411
}

type CreatePetPreconditionFailed struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus412
}

type CreatePetRequestEntityTooLarge struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus413
}

type CreatePetRequestURITooLong struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus414
}

type CreatePetUnsupportedMediaType struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus415
}

type CreatePetRequestedRangeNotSatisfiable struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus416
}

type CreatePetExpectationFailed struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus417
}

type CreatePetTeapot struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus418
}

type CreatePetMisdirectedRequest struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus421
}

type CreatePetUnprocessableEntity struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus422
}

type CreatePetLocked struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus423
}

type CreatePetFailedDependency struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus424
}

type CreatePetTooEarly struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus425
}

type CreatePetUpgradeRequired struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus426
}

type CreatePetPreconditionRequired struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus428
}

type CreatePetTooManyRequests struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus429
}

type CreatePetRequestHeaderFieldsTooLarge struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus431
}

type CreatePetUnavailableForLegalReasons struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus451
}

type CreatePetInternalServerError struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus500
}

type CreatePetNotImplemented struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus501
}

type CreatePetBadGateway struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus502
}

type CreatePetServiceUnavailable struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus503
}

type CreatePetGatewayTimeout struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus504
}

type CreatePetHTTPVersionNotSupported struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus505
}

type CreatePetVariantAlsoNegotiates struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus506
}

type CreatePetInsufficientStorage struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus507
}

type CreatePetLoopDetected struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus508
}

type CreatePetNotExtended struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus510
}

type CreatePetNetworkAuthenticationRequired struct {
	Error
	isTypeOf[CreatePetError]
	httpStatus511
}

// CreatePetRequest holds a constructed *http.Request that can be executed
// on the *http.Client in the passed context.Context
type CreatePetRequest struct {
	// Context in which to execute request
	Context context.Context
	// Client used to execute request
	Client *http.Client
	// Request that will be executed
	Request *http.Request
	// ResponseMiddleware functions executed on the *http.Response before it is processed by the Execute function
	ResponseMiddleware []ResponseMiddlewareFunction
	// metrics tracked during request
	Metrics *Metrics
	// Error in request creation. The Error is tracked as part of the CreatePetRequest to one-line
	// the execution in Client.PetsAPI.CreatePet.Execute()
	Error error
}

// CreatePet constructs a new CreatePetRequest
func (a *PetsService) CreatePet(ctx context.Context, body CreatePetBody) CreatePetRequest {
	res := CreatePetRequest{
		Context:            ctx,
		Client:             a.Client,
		ResponseMiddleware: a.Configuration.ResponseMiddleware,
		Metrics:            a.Configuration.Metrics,
	}

	path := a.Configuration.BasePath + "/pets"
	rawPath := path
	query := []string{}

	u := &url.URL{
		Scheme:   a.Configuration.Scheme,
		Host:     fmt.Sprintf("%s:%d", a.Configuration.Host, a.Configuration.Port),
		Path:     path,
		RawQuery: strings.Join(query, "&"),
	}

	if path != rawPath {
		u.RawPath = rawPath
	}

	// set headers for request
	header := map[string][]string{}
	for k, v := range a.Configuration.DefaultHeader {
		header[k] = []string{v}
	}

	req := &http.Request{
		Method: http.MethodPost,
		URL:    u,
		Header: header,
		Host:   a.Configuration.Host,
	}

	// add context to request
	req = req.WithContext(ctx)

	// inject trace in request
	carrier := propagation.HeaderCarrier(req.Header)
	propagator := otel.GetTextMapPropagator()
	propagator.Inject(ctx, carrier)
	// add body to request
	header["Content-Type"] = []string{"application/json"}
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		logrus.WithContext(ctx).WithError(err).Errorf("failed to marshal JSON body %v", body)
		res.Error = err
		return res
	}
	req.Body = io.NopCloser(bytes.NewReader(bodyBytes))

	// Apply middlewares
	for _, middleware := range a.Configuration.RequestMiddleware {
		if err := middleware(req); err != nil {
			res.Error = err
			return res
		}
	}

	res.Request = req
	return res
}

// CreatePetExecute a CreatePetRequest on the PetsService
// as a convenience function.
func (a *PetsService) CreatePetExecute(r CreatePetRequest) (CreatePetSuccess, CreatePetError, *http.Response, error) {
	return r.Execute()
}

// CreatePet the CreatePetRequest towards [POST] /pets and
// return either the success response (1xx-3xx) or failure response (4xx-5xx), the raw *http.Response or an error if the request could not be executed
func (r CreatePetRequest) Execute() (CreatePetSuccess, CreatePetError, *http.Response, error) {
	ctx, span := otel.Tracer("").Start(r.Context, "CreatePet")
	log := logrus.WithContext(ctx)
	defer span.End()

	var statusCode int
	before := time.Now()
	if m := r.Metrics; m != nil {
		defer func() {
			m.Counter.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.PetsCounter.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.CreatePetCounter.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			if statusCode != 0 {
				duration := time.Since(before)
				m.Histogram.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.PetsHistogram.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.CreatePetHistogram.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
			}
		}()
	}

	res, err := r.Client.Do(r.Request)
	if err != nil {
		log.WithError(err).Errorf("failed to perform request for path '%s'", r.Request.URL.Path)
		return nil, nil, nil, err
	}

	// for metrics
	statusCode = res.StatusCode

	// Apply middlewares
	for _, middleware := range r.ResponseMiddleware {
		if err := middleware(res); err != nil {
			log.WithError(err).Errorf("response middleware returns error for path '%s'", r.Request.URL.Path)
			return nil, nil, res, err
		}
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to parse body for status code '%d'", res.StatusCode)
		return nil, nil, res, err
	}

	switch res.StatusCode {
	case http.StatusCreated:
		var success CreatePetCreated
		if err := json.Unmarshal(bodyBytes, &success); err != nil {
			log.WithError(err).Errorf("failed to unmarshal body for status code '%d': %v", 201, string(bodyBytes))
			return nil, nil, res, err
		}
		return &success, nil, res, nil
	case http.StatusBadRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 400, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnauthorized:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 401, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPaymentRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 402, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusForbidden:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 403, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotFound:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 404, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusMethodNotAllowed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 405, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotAcceptable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 406, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusProxyAuthRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 407, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestTimeout:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 408, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusConflict:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 409, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusGone:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 410, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLengthRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 411, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPreconditionFailed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 412, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestEntityTooLarge:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 413, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestURITooLong:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 414, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnsupportedMediaType:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 415, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestedRangeNotSatisfiable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 416, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusExpectationFailed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 417, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTeapot:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 418, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusMisdirectedRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 421, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnprocessableEntity:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 422, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLocked:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 423, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusFailedDependency:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 424, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTooEarly:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 425, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUpgradeRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 426, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPreconditionRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 428, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTooManyRequests:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 429, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestHeaderFieldsTooLarge:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 431, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnavailableForLegalReasons:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 451, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInternalServerError:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 500, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotImplemented:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 501, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusBadGateway:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 502, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusServiceUnavailable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 503, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusGatewayTimeout:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 504, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusHTTPVersionNotSupported:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 505, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusVariantAlsoNegotiates:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 506, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInsufficientStorage:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 507, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLoopDetected:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 508, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotExtended:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 510, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNetworkAuthenticationRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 511, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	}

	// if a response is received that is not specified in the OpenAPI specification, log the response with an error
	if res.Body == nil {
		err := fmt.Errorf("received unknown response '%d' without body", res.StatusCode)
		log.Error(err.Error())

		return nil, nil, res, err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to read body for unknown response with status code '%d'", res.StatusCode)

		return nil, nil, res, err
	}

	err = fmt.Errorf("received unknown response '%d' with body %v", res.StatusCode, string(b))
	log.WithError(err).Error("failed to execute request")

	return nil, nil, res, err
}

// DeletePetSuccess must be implemented by all responses for DELETE /pets/{id} that indicate success
type DeletePetSuccess interface {
	requireTypeOf[DeletePetSuccess]
}

// DeletePetError must be implemented by all responses DELETE /pets/{id} that indicate failure
type DeletePetError interface {
	requireTypeOf[DeletePetError]
}

// DeletePetParams are parsed from the URL for DELETE /pets/{id}
type DeletePetParams struct {
	ID string `json:"id" uri:"id"`
}

type DeletePetNoContent struct {
	isTypeOf[DeletePetSuccess]
	httpStatus204
}

type DeletePetBadRequest struct {
	isTypeOf[DeletePetError]
	httpStatus400
}

type DeletePetNotFound struct {
	isTypeOf[DeletePetError]
	httpStatus404
}

type DeletePetInternalServerError struct {
	isTypeOf[DeletePetError]
	httpStatus500
}

// DeletePetRequest holds a constructed *http.Request that can be executed
// on the *http.Client in the passed context.Context
type DeletePetRequest struct {
	// Context in which to execute request
	Context context.Context
	// Client used to execute request
	Client *http.Client
	// Request that will be executed
	Request *http.Request
	// ResponseMiddleware functions executed on the *http.Response before it is processed by the Execute function
	ResponseMiddleware []ResponseMiddlewareFunction
	// metrics tracked during request
	Metrics *Metrics
	// Error in request creation. The Error is tracked as part of the DeletePetRequest to one-line
	// the execution in Client.PetsAPI.DeletePet.Execute()
	Error error
}

// DeletePet constructs a new DeletePetRequest
func (a *PetsService) DeletePet(ctx context.Context, params DeletePetParams) DeletePetRequest {
	res := DeletePetRequest{
		Context:            ctx,
		Client:             a.Client,
		ResponseMiddleware: a.Configuration.ResponseMiddleware,
		Metrics:            a.Configuration.Metrics,
	}

	path := a.Configuration.BasePath + "/pets/{id}"
	rawPath := path
	path = strings.Replace(path, ":id", fmt.Sprint(params.ID), 1)
	rawPath = strings.Replace(rawPath, ":id", url.PathEscape(fmt.Sprint(params.ID)), 1)
	query := []string{}

	u := &url.URL{
		Scheme:   a.Configuration.Scheme,
		Host:     fmt.Sprintf("%s:%d", a.Configuration.Host, a.Configuration.Port),
		Path:     path,
		RawQuery: strings.Join(query, "&"),
	}

	if path != rawPath {
		u.RawPath = rawPath
	}

	// set headers for request
	header := map[string][]string{}
	for k, v := range a.Configuration.DefaultHeader {
		header[k] = []string{v}
	}

	req := &http.Request{
		Method: http.MethodDelete,
		URL:    u,
		Header: header,
		Host:   a.Configuration.Host,
	}

	// add context to request
	req = req.WithContext(ctx)

	// inject trace in request
	carrier := propagation.HeaderCarrier(req.Header)
	propagator := otel.GetTextMapPropagator()
	propagator.Inject(ctx, carrier)

	// Apply middlewares
	for _, middleware := range a.Configuration.RequestMiddleware {
		if err := middleware(req); err != nil {
			res.Error = err
			return res
		}
	}

	res.Request = req
	return res
}

// DeletePetExecute a DeletePetRequest on the PetsService
// as a convenience function.
func (a *PetsService) DeletePetExecute(r DeletePetRequest) (DeletePetSuccess, DeletePetError, *http.Response, error) {
	return r.Execute()
}

// DeletePet the DeletePetRequest towards [DELETE] /pets/{id} and
// return either the success response (1xx-3xx) or failure response (4xx-5xx), the raw *http.Response or an error if the request could not be executed
func (r DeletePetRequest) Execute() (DeletePetSuccess, DeletePetError, *http.Response, error) {
	ctx, span := otel.Tracer("").Start(r.Context, "DeletePet")
	log := logrus.WithContext(ctx)
	defer span.End()

	var statusCode int
	before := time.Now()
	if m := r.Metrics; m != nil {
		defer func() {
			m.Counter.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.PetsCounter.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.DeletePetCounter.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			if statusCode != 0 {
				duration := time.Since(before)
				m.Histogram.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.PetsHistogram.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.DeletePetHistogram.With(prometheus.Labels{labelHttpMethod: "DELETE", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
			}
		}()
	}

	res, err := r.Client.Do(r.Request)
	if err != nil {
		log.WithError(err).Errorf("failed to perform request for path '%s'", r.Request.URL.Path)
		return nil, nil, nil, err
	}

	// for metrics
	statusCode = res.StatusCode

	// Apply middlewares
	for _, middleware := range r.ResponseMiddleware {
		if err := middleware(res); err != nil {
			log.WithError(err).Errorf("response middleware returns error for path '%s'", r.Request.URL.Path)
			return nil, nil, res, err
		}
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to parse body for status code '%d'", res.StatusCode)
		return nil, nil, res, err
	}

	switch res.StatusCode {
	case http.StatusNoContent:
		var success DeletePetNoContent
		if err := json.Unmarshal(bodyBytes, &success); err != nil {
			log.WithError(err).Errorf("failed to unmarshal body for status code '%d': %v", 204, string(bodyBytes))
			return nil, nil, res, err
		}
		return &success, nil, res, nil
	case http.StatusBadRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 400, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotFound:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 404, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInternalServerError:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 500, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	}

	// if a response is received that is not specified in the OpenAPI specification, log the response with an error
	if res.Body == nil {
		err := fmt.Errorf("received unknown response '%d' without body", res.StatusCode)
		log.Error(err.Error())

		return nil, nil, res, err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to read body for unknown response with status code '%d'", res.StatusCode)

		return nil, nil, res, err
	}

	err = fmt.Errorf("received unknown response '%d' with body %v", res.StatusCode, string(b))
	log.WithError(err).Error("failed to execute request")

	return nil, nil, res, err
}

// ShowPetByIDSuccess must be implemented by all responses for GET /pets/{id} that indicate success
type ShowPetByIDSuccess interface {
	requireTypeOf[ShowPetByIDSuccess]
}

// ShowPetByIDError must be implemented by all responses GET /pets/{id} that indicate failure
type ShowPetByIDError interface {
	requireTypeOf[ShowPetByIDError]
}

// ShowPetByIDParams are parsed from the URL for GET /pets/{id}
type ShowPetByIDParams struct {
	ID string `json:"id" uri:"id"`
}

type ShowPetByIDOk struct {
	isTypeOf[ShowPetByIDSuccess]
	httpStatus200
	// MetaData contains metadata of the response, such as record count, pagination and other additional information.
	Meta DefaultResponseMeta
	Data Pet
	// Errors specifies a List of errors that occurred, can be filled using error handlers.
	Errors DefaultResponseErrors
}

type ShowPetByIDBadRequest struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus400
}

type ShowPetByIDUnauthorized struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus401
}

type ShowPetByIDPaymentRequired struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus402
}

type ShowPetByIDForbidden struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus403
}

type ShowPetByIDNotFound struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus404
}

type ShowPetByIDMethodNotAllowed struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus405
}

type ShowPetByIDNotAcceptable struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus406
}

type ShowPetByIDProxyAuthRequired struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus407
}

type ShowPetByIDRequestTimeout struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus408
}

type ShowPetByIDConflict struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus409
}

type ShowPetByIDGone struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus410
}

type ShowPetByIDLengthRequired struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus411
}

type ShowPetByIDPreconditionFailed struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus412
}

type ShowPetByIDRequestEntityTooLarge struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus413
}

type ShowPetByIDRequestURITooLong struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus414
}

type ShowPetByIDUnsupportedMediaType struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus415
}

type ShowPetByIDRequestedRangeNotSatisfiable struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus416
}

type ShowPetByIDExpectationFailed struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus417
}

type ShowPetByIDTeapot struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus418
}

type ShowPetByIDMisdirectedRequest struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus421
}

type ShowPetByIDUnprocessableEntity struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus422
}

type ShowPetByIDLocked struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus423
}

type ShowPetByIDFailedDependency struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus424
}

type ShowPetByIDTooEarly struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus425
}

type ShowPetByIDUpgradeRequired struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus426
}

type ShowPetByIDPreconditionRequired struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus428
}

type ShowPetByIDTooManyRequests struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus429
}

type ShowPetByIDRequestHeaderFieldsTooLarge struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus431
}

type ShowPetByIDUnavailableForLegalReasons struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus451
}

type ShowPetByIDInternalServerError struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus500
}

type ShowPetByIDNotImplemented struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus501
}

type ShowPetByIDBadGateway struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus502
}

type ShowPetByIDServiceUnavailable struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus503
}

type ShowPetByIDGatewayTimeout struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus504
}

type ShowPetByIDHTTPVersionNotSupported struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus505
}

type ShowPetByIDVariantAlsoNegotiates struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus506
}

type ShowPetByIDInsufficientStorage struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus507
}

type ShowPetByIDLoopDetected struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus508
}

type ShowPetByIDNotExtended struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus510
}

type ShowPetByIDNetworkAuthenticationRequired struct {
	Error
	isTypeOf[ShowPetByIDError]
	httpStatus511
}

// ShowPetByIDRequest holds a constructed *http.Request that can be executed
// on the *http.Client in the passed context.Context
type ShowPetByIDRequest struct {
	// Context in which to execute request
	Context context.Context
	// Client used to execute request
	Client *http.Client
	// Request that will be executed
	Request *http.Request
	// ResponseMiddleware functions executed on the *http.Response before it is processed by the Execute function
	ResponseMiddleware []ResponseMiddlewareFunction
	// metrics tracked during request
	Metrics *Metrics
	// Error in request creation. The Error is tracked as part of the ShowPetByIDRequest to one-line
	// the execution in Client.PetsAPI.ShowPetByID.Execute()
	Error error
}

// ShowPetByID constructs a new ShowPetByIDRequest
func (a *PetsService) ShowPetByID(ctx context.Context, params ShowPetByIDParams) ShowPetByIDRequest {
	res := ShowPetByIDRequest{
		Context:            ctx,
		Client:             a.Client,
		ResponseMiddleware: a.Configuration.ResponseMiddleware,
		Metrics:            a.Configuration.Metrics,
	}

	path := a.Configuration.BasePath + "/pets/{id}"
	rawPath := path
	path = strings.Replace(path, ":id", fmt.Sprint(params.ID), 1)
	rawPath = strings.Replace(rawPath, ":id", url.PathEscape(fmt.Sprint(params.ID)), 1)
	query := []string{}

	u := &url.URL{
		Scheme:   a.Configuration.Scheme,
		Host:     fmt.Sprintf("%s:%d", a.Configuration.Host, a.Configuration.Port),
		Path:     path,
		RawQuery: strings.Join(query, "&"),
	}

	if path != rawPath {
		u.RawPath = rawPath
	}

	// set headers for request
	header := map[string][]string{}
	for k, v := range a.Configuration.DefaultHeader {
		header[k] = []string{v}
	}

	req := &http.Request{
		Method: http.MethodGet,
		URL:    u,
		Header: header,
		Host:   a.Configuration.Host,
	}

	// add context to request
	req = req.WithContext(ctx)

	// inject trace in request
	carrier := propagation.HeaderCarrier(req.Header)
	propagator := otel.GetTextMapPropagator()
	propagator.Inject(ctx, carrier)

	// Apply middlewares
	for _, middleware := range a.Configuration.RequestMiddleware {
		if err := middleware(req); err != nil {
			res.Error = err
			return res
		}
	}

	res.Request = req
	return res
}

// ShowPetByIDExecute a ShowPetByIDRequest on the PetsService
// as a convenience function.
func (a *PetsService) ShowPetByIDExecute(r ShowPetByIDRequest) (ShowPetByIDSuccess, ShowPetByIDError, *http.Response, error) {
	return r.Execute()
}

// ShowPetByID the ShowPetByIDRequest towards [GET] /pets/{id} and
// return either the success response (1xx-3xx) or failure response (4xx-5xx), the raw *http.Response or an error if the request could not be executed
func (r ShowPetByIDRequest) Execute() (ShowPetByIDSuccess, ShowPetByIDError, *http.Response, error) {
	ctx, span := otel.Tracer("").Start(r.Context, "ShowPetById")
	log := logrus.WithContext(ctx)
	defer span.End()

	var statusCode int
	before := time.Now()
	if m := r.Metrics; m != nil {
		defer func() {
			m.Counter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.PetsCounter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.ShowPetByIDCounter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			if statusCode != 0 {
				duration := time.Since(before)
				m.Histogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.PetsHistogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.ShowPetByIDHistogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
			}
		}()
	}

	res, err := r.Client.Do(r.Request)
	if err != nil {
		log.WithError(err).Errorf("failed to perform request for path '%s'", r.Request.URL.Path)
		return nil, nil, nil, err
	}

	// for metrics
	statusCode = res.StatusCode

	// Apply middlewares
	for _, middleware := range r.ResponseMiddleware {
		if err := middleware(res); err != nil {
			log.WithError(err).Errorf("response middleware returns error for path '%s'", r.Request.URL.Path)
			return nil, nil, res, err
		}
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to parse body for status code '%d'", res.StatusCode)
		return nil, nil, res, err
	}

	switch res.StatusCode {
	case http.StatusOK:
		var success ShowPetByIDOk
		if err := json.Unmarshal(bodyBytes, &success); err != nil {
			log.WithError(err).Errorf("failed to unmarshal body for status code '%d': %v", 200, string(bodyBytes))
			return nil, nil, res, err
		}
		return &success, nil, res, nil
	case http.StatusBadRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 400, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnauthorized:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 401, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPaymentRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 402, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusForbidden:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 403, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotFound:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 404, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusMethodNotAllowed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 405, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotAcceptable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 406, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusProxyAuthRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 407, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestTimeout:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 408, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusConflict:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 409, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusGone:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 410, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLengthRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 411, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPreconditionFailed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 412, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestEntityTooLarge:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 413, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestURITooLong:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 414, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnsupportedMediaType:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 415, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestedRangeNotSatisfiable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 416, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusExpectationFailed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 417, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTeapot:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 418, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusMisdirectedRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 421, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnprocessableEntity:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 422, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLocked:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 423, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusFailedDependency:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 424, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTooEarly:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 425, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUpgradeRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 426, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPreconditionRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 428, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTooManyRequests:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 429, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestHeaderFieldsTooLarge:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 431, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnavailableForLegalReasons:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 451, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInternalServerError:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 500, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotImplemented:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 501, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusBadGateway:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 502, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusServiceUnavailable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 503, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusGatewayTimeout:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 504, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusHTTPVersionNotSupported:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 505, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusVariantAlsoNegotiates:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 506, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInsufficientStorage:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 507, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLoopDetected:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 508, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotExtended:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 510, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNetworkAuthenticationRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 511, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	}

	// if a response is received that is not specified in the OpenAPI specification, log the response with an error
	if res.Body == nil {
		err := fmt.Errorf("received unknown response '%d' without body", res.StatusCode)
		log.Error(err.Error())

		return nil, nil, res, err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to read body for unknown response with status code '%d'", res.StatusCode)

		return nil, nil, res, err
	}

	err = fmt.Errorf("received unknown response '%d' with body %v", res.StatusCode, string(b))
	log.WithError(err).Error("failed to execute request")

	return nil, nil, res, err
}

// UpdatePetSuccess must be implemented by all responses for PUT /pets/{id} that indicate success
type UpdatePetSuccess interface {
	requireTypeOf[UpdatePetSuccess]
}

// UpdatePetError must be implemented by all responses PUT /pets/{id} that indicate failure
type UpdatePetError interface {
	requireTypeOf[UpdatePetError]
}

// UpdatePetParams are parsed from the URL for PUT /pets/{id}
type UpdatePetParams struct {
	ID string `json:"id" uri:"id"`
}

type UpdatePetOk struct {
	isTypeOf[UpdatePetSuccess]
	httpStatus200
	// MetaData contains metadata of the response, such as record count, pagination and other additional information.
	Meta DefaultResponseMeta
	Data Pet
	// Errors specifies a List of errors that occurred, can be filled using error handlers.
	Errors DefaultResponseErrors
}

type UpdatePetBadRequest struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus400
}

type UpdatePetUnauthorized struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus401
}

type UpdatePetPaymentRequired struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus402
}

type UpdatePetForbidden struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus403
}

type UpdatePetNotFound struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus404
}

type UpdatePetMethodNotAllowed struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus405
}

type UpdatePetNotAcceptable struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus406
}

type UpdatePetProxyAuthRequired struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus407
}

type UpdatePetRequestTimeout struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus408
}

type UpdatePetConflict struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus409
}

type UpdatePetGone struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus410
}

type UpdatePetLengthRequired struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus411
}

type UpdatePetPreconditionFailed struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus412
}

type UpdatePetRequestEntityTooLarge struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus413
}

type UpdatePetRequestURITooLong struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus414
}

type UpdatePetUnsupportedMediaType struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus415
}

type UpdatePetRequestedRangeNotSatisfiable struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus416
}

type UpdatePetExpectationFailed struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus417
}

type UpdatePetTeapot struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus418
}

type UpdatePetMisdirectedRequest struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus421
}

type UpdatePetUnprocessableEntity struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus422
}

type UpdatePetLocked struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus423
}

type UpdatePetFailedDependency struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus424
}

type UpdatePetTooEarly struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus425
}

type UpdatePetUpgradeRequired struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus426
}

type UpdatePetPreconditionRequired struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus428
}

type UpdatePetTooManyRequests struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus429
}

type UpdatePetRequestHeaderFieldsTooLarge struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus431
}

type UpdatePetUnavailableForLegalReasons struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus451
}

type UpdatePetInternalServerError struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus500
}

type UpdatePetNotImplemented struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus501
}

type UpdatePetBadGateway struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus502
}

type UpdatePetServiceUnavailable struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus503
}

type UpdatePetGatewayTimeout struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus504
}

type UpdatePetHTTPVersionNotSupported struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus505
}

type UpdatePetVariantAlsoNegotiates struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus506
}

type UpdatePetInsufficientStorage struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus507
}

type UpdatePetLoopDetected struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus508
}

type UpdatePetNotExtended struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus510
}

type UpdatePetNetworkAuthenticationRequired struct {
	Error
	isTypeOf[UpdatePetError]
	httpStatus511
}

// UpdatePetRequest holds a constructed *http.Request that can be executed
// on the *http.Client in the passed context.Context
type UpdatePetRequest struct {
	// Context in which to execute request
	Context context.Context
	// Client used to execute request
	Client *http.Client
	// Request that will be executed
	Request *http.Request
	// ResponseMiddleware functions executed on the *http.Response before it is processed by the Execute function
	ResponseMiddleware []ResponseMiddlewareFunction
	// metrics tracked during request
	Metrics *Metrics
	// Error in request creation. The Error is tracked as part of the UpdatePetRequest to one-line
	// the execution in Client.PetsAPI.UpdatePet.Execute()
	Error error
}

// UpdatePet constructs a new UpdatePetRequest
func (a *PetsService) UpdatePet(ctx context.Context, params UpdatePetParams) UpdatePetRequest {
	res := UpdatePetRequest{
		Context:            ctx,
		Client:             a.Client,
		ResponseMiddleware: a.Configuration.ResponseMiddleware,
		Metrics:            a.Configuration.Metrics,
	}

	path := a.Configuration.BasePath + "/pets/{id}"
	rawPath := path
	path = strings.Replace(path, ":id", fmt.Sprint(params.ID), 1)
	rawPath = strings.Replace(rawPath, ":id", url.PathEscape(fmt.Sprint(params.ID)), 1)
	query := []string{}

	u := &url.URL{
		Scheme:   a.Configuration.Scheme,
		Host:     fmt.Sprintf("%s:%d", a.Configuration.Host, a.Configuration.Port),
		Path:     path,
		RawQuery: strings.Join(query, "&"),
	}

	if path != rawPath {
		u.RawPath = rawPath
	}

	// set headers for request
	header := map[string][]string{}
	for k, v := range a.Configuration.DefaultHeader {
		header[k] = []string{v}
	}

	req := &http.Request{
		Method: http.MethodPut,
		URL:    u,
		Header: header,
		Host:   a.Configuration.Host,
	}

	// add context to request
	req = req.WithContext(ctx)

	// inject trace in request
	carrier := propagation.HeaderCarrier(req.Header)
	propagator := otel.GetTextMapPropagator()
	propagator.Inject(ctx, carrier)

	// Apply middlewares
	for _, middleware := range a.Configuration.RequestMiddleware {
		if err := middleware(req); err != nil {
			res.Error = err
			return res
		}
	}

	res.Request = req
	return res
}

// UpdatePetExecute a UpdatePetRequest on the PetsService
// as a convenience function.
func (a *PetsService) UpdatePetExecute(r UpdatePetRequest) (UpdatePetSuccess, UpdatePetError, *http.Response, error) {
	return r.Execute()
}

// UpdatePet the UpdatePetRequest towards [PUT] /pets/{id} and
// return either the success response (1xx-3xx) or failure response (4xx-5xx), the raw *http.Response or an error if the request could not be executed
func (r UpdatePetRequest) Execute() (UpdatePetSuccess, UpdatePetError, *http.Response, error) {
	ctx, span := otel.Tracer("").Start(r.Context, "UpdatePet")
	log := logrus.WithContext(ctx)
	defer span.End()

	var statusCode int
	before := time.Now()
	if m := r.Metrics; m != nil {
		defer func() {
			m.Counter.With(prometheus.Labels{labelHttpMethod: "PUT", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.PetsCounter.With(prometheus.Labels{labelHttpMethod: "PUT", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.UpdatePetCounter.With(prometheus.Labels{labelHttpMethod: "PUT", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			if statusCode != 0 {
				duration := time.Since(before)
				m.Histogram.With(prometheus.Labels{labelHttpMethod: "PUT", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.PetsHistogram.With(prometheus.Labels{labelHttpMethod: "PUT", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.UpdatePetHistogram.With(prometheus.Labels{labelHttpMethod: "PUT", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
			}
		}()
	}

	res, err := r.Client.Do(r.Request)
	if err != nil {
		log.WithError(err).Errorf("failed to perform request for path '%s'", r.Request.URL.Path)
		return nil, nil, nil, err
	}

	// for metrics
	statusCode = res.StatusCode

	// Apply middlewares
	for _, middleware := range r.ResponseMiddleware {
		if err := middleware(res); err != nil {
			log.WithError(err).Errorf("response middleware returns error for path '%s'", r.Request.URL.Path)
			return nil, nil, res, err
		}
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to parse body for status code '%d'", res.StatusCode)
		return nil, nil, res, err
	}

	switch res.StatusCode {
	case http.StatusOK:
		var success UpdatePetOk
		if err := json.Unmarshal(bodyBytes, &success); err != nil {
			log.WithError(err).Errorf("failed to unmarshal body for status code '%d': %v", 200, string(bodyBytes))
			return nil, nil, res, err
		}
		return &success, nil, res, nil
	case http.StatusBadRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 400, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnauthorized:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 401, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPaymentRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 402, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusForbidden:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 403, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotFound:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 404, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusMethodNotAllowed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 405, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotAcceptable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 406, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusProxyAuthRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 407, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestTimeout:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 408, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusConflict:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 409, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusGone:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 410, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLengthRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 411, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPreconditionFailed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 412, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestEntityTooLarge:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 413, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestURITooLong:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 414, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnsupportedMediaType:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 415, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestedRangeNotSatisfiable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 416, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusExpectationFailed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 417, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTeapot:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 418, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusMisdirectedRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 421, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnprocessableEntity:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 422, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLocked:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 423, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusFailedDependency:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 424, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTooEarly:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 425, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUpgradeRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 426, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusPreconditionRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 428, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusTooManyRequests:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 429, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusRequestHeaderFieldsTooLarge:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 431, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusUnavailableForLegalReasons:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 451, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInternalServerError:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 500, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotImplemented:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 501, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusBadGateway:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 502, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusServiceUnavailable:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 503, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusGatewayTimeout:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 504, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusHTTPVersionNotSupported:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 505, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusVariantAlsoNegotiates:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 506, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusInsufficientStorage:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 507, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusLoopDetected:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 508, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotExtended:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 510, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNetworkAuthenticationRequired:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 511, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	}

	// if a response is received that is not specified in the OpenAPI specification, log the response with an error
	if res.Body == nil {
		err := fmt.Errorf("received unknown response '%d' without body", res.StatusCode)
		log.Error(err.Error())

		return nil, nil, res, err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to read body for unknown response with status code '%d'", res.StatusCode)

		return nil, nil, res, err
	}

	err = fmt.Errorf("received unknown response '%d' with body %v", res.StatusCode, string(b))
	log.WithError(err).Error("failed to execute request")

	return nil, nil, res, err
}
