// Code generated by P30599-IPC-Generator/ipcgen/internal/built-in-plugins/client; DO NOT EDIT.
package testsdkgo

import (
	"encoding/base64"
	"errors"
	"net/http"
	"sync"

	"dev.azure.com/INGCDaaS/IngOne/_git/P19673-go-modules.git/cyberarkaimccp/types"
	"github.com/sirupsen/logrus"
)

// reauthenticate handles a failed request responding with either 401 (StatusUnauthorized) or 403 (StatusForbidden)
// by reauthenticating. The amount of retries can be controlled with the WithAttempts() option.
//
// For any value larger than 0 the following will happen
// attempt 0: use default credentials if 401 or 403 retry
// attempt 1: refresh with CCP using cache if 401 or 403 retry
// attempt 2+: refresh with CCP without cache
type reauthenticate struct {
	// transport is the underlying transport used to make the requests
	transport http.RoundTripper

	// requests[*http.Request]int counts the attempts per request
	requests sync.Map

	// config used during RoundTrip
	config config

	// client configuration
	client *Configuration
}

// CentralCredentialProviderCallback is invoked when the credentials are refreshed by the CyberArk CCP middleware and allows
// to modify the current *http.Request before the request is retried or for example update the client *Configuration with a
// new default header containing the authentication details
//
// See for example BasicAuth
type CentralCredentialProviderCallback func(credentials types.CyberArkAIMCCPCredential, req *http.Request, client *Configuration)

// BasicAuth is a CentralCredentialProviderCallback that handles the callback using BasicAuth, see:
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication
func BasicAuth(credentials types.CyberArkAIMCCPCredential, req *http.Request, client *Configuration) {
	req.SetBasicAuth(credentials.Username, credentials.Password)
	client.DefaultHeader["Authorization"] = "Basic " + base64.StdEncoding.EncodeToString([]byte(credentials.Username+":"+credentials.Password))
}

// config used during RoundTrip of a reauthenticate enabled *http.Client
type config struct {
	// callback when credentials are refreshed
	callback CentralCredentialProviderCallback
	// params used for refreshing the NPA
	params *types.PasswordParams
	// client used for refreshing credentials
	client CCPClient
	// attempts before cancelling requests, must be >=1 as the 0th attempt is always performed
	attempts int
}

// WithAttempts controls the amount of attempts before a request is cancelled. The amount must be bigger than 0 as
// the 0th attempt is always made (default request without retry)
func WithAttempts(attempts int) option[config] {
	return func(c *config) error {
		if attempts <= 0 {
			return errors.New("attempts must be greater than 0")
		}

		return nil
	}
}

// CCPClient that is able to translate PasswordParams into credentials either using cache or not. This interface
// is implemented in dev.azure.com/INGCDaaS/IngOne/_git/P19673-go-modules.git/cyberarkaimccp.Client::Get
// which can be used as a direct implementation
type CCPClient interface {
	// Get the credentials from CyberArk or from cache if configured.
	Get(pp *types.PasswordParams, cached ...bool) (credential types.CyberArkAIMCCPCredential, err error)
}

// RoundTrip first executes the request with the default roundtripper ensuring that it does not influence the
// default operations. However, if the request is either 401 or 403 and the amount of allowed attempts is not
// exceeded, retry the request and refresh the credentials.
func (r *reauthenticate) RoundTrip(request *http.Request) (*http.Response, error) {
	res, err := r.transport.RoundTrip(request)
	val, ok := r.requests.Load(request)

	// if the request is not http.StatusForbidden nor http.StatusUnauthorized or it has already been retried but the
	// number of attempts is bigger than the maximum configured events
	if (res.StatusCode != http.StatusForbidden && res.StatusCode != http.StatusUnauthorized) || (ok && val.(int) >= r.config.attempts) {
		// attempts exceeded or error unrelated to authorisation
		r.requests.Delete(request) // cleanup
		return res, err
	}

	// track retries
	attempt := 1
	if ok {
		attempt = attempt + val.(int)
	}
	r.requests.Store(request, attempt)

	// use cache in first retry
	usecache := true
	if attempt > 1 {
		usecache = false
	}

	// refresh credentials
	credential, err2 := r.config.client.Get(r.config.params, usecache)
	if err2 != nil {
		logrus.WithContext(request.Context()).WithError(err2).Info("failed to refresh credentials")
		r.requests.Delete(request) // cleanup
		return res, err
	}

	// let callback be handled
	r.config.callback(credential, request, r.client)

	// retry request
	return r.RoundTrip(request)
}
