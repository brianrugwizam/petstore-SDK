// Code generated by P30599-IPC-Generator/ipcgen/internal/built-in-plugins/client; DO NOT EDIT.
package testsdkgo

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/sirupsen/logrus"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
)

// StoreAPI holds the operations grouped on the 'store' tag.
type StoreAPI interface {
	// PlaceOrder creates a new PlaceOrderRequest for 'PlaceOrder'
	// @Summary Place an order for a pet
	// @Tags [store]
	// @Success 200 PlaceOrderOK
	// @Failure 405 PlaceOrderMethodNotAllowed
	// @Router POST [/store/order]
	//
	// The request can be executed using PlaceOrderRequest.Execute()
	PlaceOrder(context.Context, PlaceOrderBody) PlaceOrderRequest

	// PlaceOrderExecute executes a PlaceOrderRequest to return one
	// of the possible PlaceOrder success/error responses, the raw *http.Response and an error
	PlaceOrderExecute(PlaceOrderRequest) (PlaceOrderSuccess, PlaceOrderError, *http.Response, error)

	// GetOrderByID creates a new GetOrderByIDRequest for 'GetOrderById'
	// @Summary Find purchase order by ID
	// @Tags [store]
	// @Param orderId path ID of order that needs to be fetched
	// @Success 200 GetOrderByIDOK
	// @Failure 400 GetOrderByIDBadRequest
	// @Failure 404 GetOrderByIDNotFound
	// @Router GET [/store/order/{orderId}]
	//
	// The request can be executed using GetOrderByIDRequest.Execute()
	GetOrderByID(context.Context, GetOrderByIDParams) GetOrderByIDRequest

	// GetOrderByIDExecute executes a GetOrderByIDRequest to return one
	// of the possible GetOrderById success/error responses, the raw *http.Response and an error
	GetOrderByIDExecute(GetOrderByIDRequest) (GetOrderByIDSuccess, GetOrderByIDError, *http.Response, error)
}

// StoreService is registered on the root Client and can create requests for the
// operations grouped on 'store' and execute them.
type StoreService struct {
	// Client used to execute requests
	Client *http.Client
	// Configuration used to create requests
	Configuration *Configuration
}

// PlaceOrderSuccess must be implemented by all responses for POST /store/order that indicate success
type PlaceOrderSuccess interface {
	requireTypeOf[PlaceOrderSuccess]
}

// PlaceOrderError must be implemented by all responses POST /store/order that indicate failure
type PlaceOrderError interface {
	requireTypeOf[PlaceOrderError]
}

// PlaceOrderBody are parsed from the request body for POST /store/order
type PlaceOrderBody struct {
	ID   int
	Name string
}

type PlaceOrderOk struct {
	isTypeOf[PlaceOrderSuccess]
	httpStatus200
}

type PlaceOrderMethodNotAllowed struct {
	isTypeOf[PlaceOrderError]
	httpStatus405
}

// PlaceOrderRequest holds a constructed *http.Request that can be executed
// on the *http.Client in the passed context.Context
type PlaceOrderRequest struct {
	// Context in which to execute request
	Context context.Context
	// Client used to execute request
	Client *http.Client
	// Request that will be executed
	Request *http.Request
	// ResponseMiddleware functions executed on the *http.Response before it is processed by the Execute function
	ResponseMiddleware []ResponseMiddlewareFunction
	// metrics tracked during request
	Metrics *Metrics
	// Error in request creation. The Error is tracked as part of the PlaceOrderRequest to one-line
	// the execution in Client.StoreAPI.PlaceOrder.Execute()
	Error error
}

// PlaceOrder constructs a new PlaceOrderRequest
func (a *StoreService) PlaceOrder(ctx context.Context, body PlaceOrderBody) PlaceOrderRequest {
	res := PlaceOrderRequest{
		Context:            ctx,
		Client:             a.Client,
		ResponseMiddleware: a.Configuration.ResponseMiddleware,
		Metrics:            a.Configuration.Metrics,
	}

	path := a.Configuration.BasePath + "/store/order"
	rawPath := path
	query := []string{}

	u := &url.URL{
		Scheme:   a.Configuration.Scheme,
		Host:     fmt.Sprintf("%s:%d", a.Configuration.Host, a.Configuration.Port),
		Path:     path,
		RawQuery: strings.Join(query, "&"),
	}

	if path != rawPath {
		u.RawPath = rawPath
	}

	// set headers for request
	header := map[string][]string{}
	for k, v := range a.Configuration.DefaultHeader {
		header[k] = []string{v}
	}

	req := &http.Request{
		Method: http.MethodPost,
		URL:    u,
		Header: header,
		Host:   a.Configuration.Host,
	}

	// add context to request
	req = req.WithContext(ctx)

	// inject trace in request
	carrier := propagation.HeaderCarrier(req.Header)
	propagator := otel.GetTextMapPropagator()
	propagator.Inject(ctx, carrier)
	// add body to request
	header["Content-Type"] = []string{"application/json"}
	bodyBytes, err := json.Marshal(body)
	if err != nil {
		logrus.WithContext(ctx).WithError(err).Errorf("failed to marshal JSON body %v", body)
		res.Error = err
		return res
	}
	req.Body = io.NopCloser(bytes.NewReader(bodyBytes))

	// Apply middlewares
	for _, middleware := range a.Configuration.RequestMiddleware {
		if err := middleware(req); err != nil {
			res.Error = err
			return res
		}
	}

	res.Request = req
	return res
}

// PlaceOrderExecute a PlaceOrderRequest on the StoreService
// as a convenience function.
func (a *StoreService) PlaceOrderExecute(r PlaceOrderRequest) (PlaceOrderSuccess, PlaceOrderError, *http.Response, error) {
	return r.Execute()
}

// PlaceOrder the PlaceOrderRequest towards [POST] /store/order and
// return either the success response (1xx-3xx) or failure response (4xx-5xx), the raw *http.Response or an error if the request could not be executed
func (r PlaceOrderRequest) Execute() (PlaceOrderSuccess, PlaceOrderError, *http.Response, error) {
	ctx, span := otel.Tracer("").Start(r.Context, "PlaceOrder")
	log := logrus.WithContext(ctx)
	defer span.End()

	var statusCode int
	before := time.Now()
	if m := r.Metrics; m != nil {
		defer func() {
			m.Counter.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.StoreCounter.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.PlaceOrderCounter.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			if statusCode != 0 {
				duration := time.Since(before)
				m.Histogram.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.StoreHistogram.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.PlaceOrderHistogram.With(prometheus.Labels{labelHttpMethod: "POST", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
			}
		}()
	}

	res, err := r.Client.Do(r.Request)
	if err != nil {
		log.WithError(err).Errorf("failed to perform request for path '%s'", r.Request.URL.Path)
		return nil, nil, nil, err
	}

	// for metrics
	statusCode = res.StatusCode

	// Apply middlewares
	for _, middleware := range r.ResponseMiddleware {
		if err := middleware(res); err != nil {
			log.WithError(err).Errorf("response middleware returns error for path '%s'", r.Request.URL.Path)
			return nil, nil, res, err
		}
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to parse body for status code '%d'", res.StatusCode)
		return nil, nil, res, err
	}

	switch res.StatusCode {
	case http.StatusOK:
		var success PlaceOrderOk
		if err := json.Unmarshal(bodyBytes, &success); err != nil {
			log.WithError(err).Errorf("failed to unmarshal body for status code '%d': %v", 200, string(bodyBytes))
			return nil, nil, res, err
		}
		return &success, nil, res, nil
	case http.StatusMethodNotAllowed:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 405, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	}

	// if a response is received that is not specified in the OpenAPI specification, log the response with an error
	if res.Body == nil {
		err := fmt.Errorf("received unknown response '%d' without body", res.StatusCode)
		log.Error(err.Error())

		return nil, nil, res, err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to read body for unknown response with status code '%d'", res.StatusCode)

		return nil, nil, res, err
	}

	err = fmt.Errorf("received unknown response '%d' with body %v", res.StatusCode, string(b))
	log.WithError(err).Error("failed to execute request")

	return nil, nil, res, err
}

// GetOrderByIDSuccess must be implemented by all responses for GET /store/order/{orderId} that indicate success
type GetOrderByIDSuccess interface {
	requireTypeOf[GetOrderByIDSuccess]
}

// GetOrderByIDError must be implemented by all responses GET /store/order/{orderId} that indicate failure
type GetOrderByIDError interface {
	requireTypeOf[GetOrderByIDError]
}

// GetOrderByIDParams are parsed from the URL for GET /store/order/{orderId}
type GetOrderByIDParams struct {
	OrderID int64 `json:"orderId" uri:"orderId"`
}

type GetOrderByIDOk struct {
	DefaultResponse
	isTypeOf[GetOrderByIDSuccess]
	httpStatus200
}

type GetOrderByIDBadRequest struct {
	isTypeOf[GetOrderByIDError]
	httpStatus400
}

type GetOrderByIDNotFound struct {
	isTypeOf[GetOrderByIDError]
	httpStatus404
}

// GetOrderByIDRequest holds a constructed *http.Request that can be executed
// on the *http.Client in the passed context.Context
type GetOrderByIDRequest struct {
	// Context in which to execute request
	Context context.Context
	// Client used to execute request
	Client *http.Client
	// Request that will be executed
	Request *http.Request
	// ResponseMiddleware functions executed on the *http.Response before it is processed by the Execute function
	ResponseMiddleware []ResponseMiddlewareFunction
	// metrics tracked during request
	Metrics *Metrics
	// Error in request creation. The Error is tracked as part of the GetOrderByIDRequest to one-line
	// the execution in Client.StoreAPI.GetOrderByID.Execute()
	Error error
}

// GetOrderByID constructs a new GetOrderByIDRequest
func (a *StoreService) GetOrderByID(ctx context.Context, params GetOrderByIDParams) GetOrderByIDRequest {
	res := GetOrderByIDRequest{
		Context:            ctx,
		Client:             a.Client,
		ResponseMiddleware: a.Configuration.ResponseMiddleware,
		Metrics:            a.Configuration.Metrics,
	}

	path := a.Configuration.BasePath + "/store/order/{orderId}"
	rawPath := path
	path = strings.Replace(path, ":orderId", fmt.Sprint(params.OrderID), 1)
	rawPath = strings.Replace(rawPath, ":orderId", url.PathEscape(fmt.Sprint(params.OrderID)), 1)
	query := []string{}

	u := &url.URL{
		Scheme:   a.Configuration.Scheme,
		Host:     fmt.Sprintf("%s:%d", a.Configuration.Host, a.Configuration.Port),
		Path:     path,
		RawQuery: strings.Join(query, "&"),
	}

	if path != rawPath {
		u.RawPath = rawPath
	}

	// set headers for request
	header := map[string][]string{}
	for k, v := range a.Configuration.DefaultHeader {
		header[k] = []string{v}
	}

	req := &http.Request{
		Method: http.MethodGet,
		URL:    u,
		Header: header,
		Host:   a.Configuration.Host,
	}

	// add context to request
	req = req.WithContext(ctx)

	// inject trace in request
	carrier := propagation.HeaderCarrier(req.Header)
	propagator := otel.GetTextMapPropagator()
	propagator.Inject(ctx, carrier)

	// Apply middlewares
	for _, middleware := range a.Configuration.RequestMiddleware {
		if err := middleware(req); err != nil {
			res.Error = err
			return res
		}
	}

	res.Request = req
	return res
}

// GetOrderByIDExecute a GetOrderByIDRequest on the StoreService
// as a convenience function.
func (a *StoreService) GetOrderByIDExecute(r GetOrderByIDRequest) (GetOrderByIDSuccess, GetOrderByIDError, *http.Response, error) {
	return r.Execute()
}

// GetOrderByID the GetOrderByIDRequest towards [GET] /store/order/{orderId} and
// return either the success response (1xx-3xx) or failure response (4xx-5xx), the raw *http.Response or an error if the request could not be executed
func (r GetOrderByIDRequest) Execute() (GetOrderByIDSuccess, GetOrderByIDError, *http.Response, error) {
	ctx, span := otel.Tracer("").Start(r.Context, "GetOrderById")
	log := logrus.WithContext(ctx)
	defer span.End()

	var statusCode int
	before := time.Now()
	if m := r.Metrics; m != nil {
		defer func() {
			m.Counter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.StoreCounter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			m.GetOrderByIDCounter.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Inc()
			if statusCode != 0 {
				duration := time.Since(before)
				m.Histogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.StoreHistogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
				m.GetOrderByIDHistogram.With(prometheus.Labels{labelHttpMethod: "GET", labelStatusCode: strconv.Itoa(statusCode)}).Observe(float64(duration.Milliseconds()))
			}
		}()
	}

	res, err := r.Client.Do(r.Request)
	if err != nil {
		log.WithError(err).Errorf("failed to perform request for path '%s'", r.Request.URL.Path)
		return nil, nil, nil, err
	}

	// for metrics
	statusCode = res.StatusCode

	// Apply middlewares
	for _, middleware := range r.ResponseMiddleware {
		if err := middleware(res); err != nil {
			log.WithError(err).Errorf("response middleware returns error for path '%s'", r.Request.URL.Path)
			return nil, nil, res, err
		}
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to parse body for status code '%d'", res.StatusCode)
		return nil, nil, res, err
	}

	switch res.StatusCode {
	case http.StatusOK:
		var success GetOrderByIDOk
		if err := json.Unmarshal(bodyBytes, &success); err != nil {
			log.WithError(err).Errorf("failed to unmarshal body for status code '%d': %v", 200, string(bodyBytes))
			return nil, nil, res, err
		}
		return &success, nil, res, nil
	case http.StatusBadRequest:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 400, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	case http.StatusNotFound:
		msg := fmt.Sprintf("request failed with status code '%d': %s", 404, string(bodyBytes))
		log.Info(msg)
		// TODO unpack into error object
		return nil, nil, res, errors.New(msg)
	}

	// if a response is received that is not specified in the OpenAPI specification, log the response with an error
	if res.Body == nil {
		err := fmt.Errorf("received unknown response '%d' without body", res.StatusCode)
		log.Error(err.Error())

		return nil, nil, res, err
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		log.WithError(err).Errorf("failed to read body for unknown response with status code '%d'", res.StatusCode)

		return nil, nil, res, err
	}

	err = fmt.Errorf("received unknown response '%d' with body %v", res.StatusCode, string(b))
	log.WithError(err).Error("failed to execute request")

	return nil, nil, res, err
}
